memory canvas:
1  |  2|  3|  4|  5|  6|  7|  8|
9  | 10| 11| 12| 13| 14| 15| 16|
17 | 18| 19| 20| 21| 22| 23| 24|

Как массив располагается в памяти:
1) у нас есть массив из 2х элементов array = [1, 2]
2) в массиве хранятся элементы целочисленного типа: int 64 bits
3) каждое число занимает 8 ячеек памяти, т.к. 1 ячейка = 1 байт => 1 число 64 / 8 = 8
4) следовательно для 2х чисел будет занято 16 ячеек памяти
5) если у нас свободно место, начиная с ячейки 3, то у нас будет занято все место с 3 по
18 ячейку

Доступ к элементу по индексу:
1) мы хотим получить элемент array[1]
2) у каждого массива хранится информация о ячейке памяти с которой начинается массив
и о его длине
3) информация для вычисления ячейки массива, где находится искомый элемент:
3 - стартовая ячейка памяти массива
1 - индекс элемента
8 - размер одного элемента массива(целого числа int64)
ячейка элемента с индексом 1 = 3 + 8 x 1 = 11
4) исходя из того что операции для получения элемента массива по его индексу
элементарные, то время доступа по индексу будет константно: O(1)

S - space(занимаемое место)
T - time(время выполнения операции)
Список операций с массивом и время их выполнения:
- get O(1) ST - получение элемента массива array[0]
- set O(1) ST - заданиче элемента массива array[0] = 3
- init O(N) ST - создание массива, так происходит потому что мы должны для каждого
элемента(N) выполнить какой-то набор операций, следовательно время создания массива
зависит от количества элементов array = [1, 3, .... N]
- traverse O(N) T; O(1) S - прохождение по элементам массива(цикл)
- copy O(N) ST - копирование массива(мы проходимся по всем элементам старого массива
и выделяем для нового массива место)
- insert O(1) S; O(N) T - вставка элемента в массив
- pop O(1) ST - удаление последнего элемента в массиве
